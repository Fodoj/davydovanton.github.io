---
layout: post
title: "Seed файл и вы"
---

1. Введение, описание проблеммы, расказ про веселье
2. разбираем задачу
3. чем пользуемся
4. Пишем
5. Что можно добавить
6. вывод

Совсем не давно на работе потребовалось заполнить совсем новый проект данными для дальнейшего тестирования и разработки. Конечно же, данные должны просто быть и первое, о чем я подумал, был seed файл, поэтому сегодня мы поговорим именно о нем. Как всем известно данный файл служит для генерации данных в рельсовых приложениях. Вы пишите скрипт, выполняете `rake db:seed` и радуетесь жизни. В моем случае данные были типовыми, а именно, нужно было сгенерировать: пользователей, посты и комментарии к этим постам. Я думаю все прекрасно понимают, как все взаимосвязанно, поэтому на этом останавливаться не вижу особого смысла.

Обычная практика многих людей - задать одинаковые данные для всех типов данных и наплодить их с десяток. Смотрится это обычно как-то так:

{% highlight ruby %}
user = {
  name:  'Jon'
  email: 'my@email.org'
  password: '12345678',
  password_confirmation: '12345678'  
  }

post = {
  title:  'My Post'
  body:   'My body'
  }

comment = { body: 'comment' }

10.times do
  my_user = User.create(user)
  my_post = my_user.create_post(post)
  my_post.create_comment(user, comment)
end
{% endhighlight %}

Но согласитесь, это скучно, банально и задевает чувство прекрасного. Поэтому давайте плюнем на все, и развлечемся создав свой собственный, изменяющийся из раза в раз мир :)

АТЕНШЕН(!!!исправить!!!): далее будет много рандома, благодаря которому поддерживать все это или искать ошибки становиться все сложнее и сложнее. Поэтому, использование генераторов основанных на рандоме не рекомендуется для продакшена. В крайнем случае использовать аккуратно и с умом.

Для того, что бы наш мир существовал, нам нужны люди. Наша цель - создать абсолютно разных пользователей, не похожих друг на друга. Конечно же, первое, что всплывает в голову - замечательный гем [faker](https://github.com/stympy/faker) который поможет нам генерировать произвольные имена и почтовые адресса для наших пользователей. Но при всем при этом, не будем забывать про нашего админа. Так же, давайте зададим рандомное количество пользователей в интервале от 18 до 25(числа, как вы догадались, могут быть абсолютно любые):

{% highlight ruby %}
user = {
  name:  admin
  email: admin@my_app.com
  password: '12345678',
  password_confirmation: '12345678'  
  }

rnd = Random.new
user_count = rnd.rand(18..23)
User.create(user)

user_count.times do
  user[:name]  = Faker::Name.name
  user[:email] = Faker::Internet.email  
  User.create(user)
end
{% endhighlight %}

Cобственно я уверен, faker поможет вам сгенерировать почти любую информацию, стоит только открыть доки. Ну а если вам не угодил faker, то существует достаточно [много](https://www.ruby-toolbox.com/categories/random_data_generation) других data генераторов.

Не думаю, что тут что-то было сложно, поэтому пререйдем к постам. Сказать по правде, в нашем проекте посты состояли из строго заданных кусков html-a поэтому тут ничего не оставалось, кроме как делать в лоб. Единственный момент, мы будем выбирать произвольно польователя, что бы от его имени создавать наш пост:

{% highlight ruby %}
posts = [
  {
    title:  'My first Post'
    body:   'My body'
  },
  {
    title:  'My second Post'
    body:   'My body'    
  },
  # Еще какое-то количество данных для постов ...
]

def rnd_user(count, rnd)
  random_user_id = rnd.rand(1..(count))
  User.find(random_user_id)
end

posts.each do |post|
  rand_user = rnd_user user_count, rnd

  post[:user_id] = rand_user.id
  created_post = rand_user.create_post(post)
end
{% endhighlight %}

Настало время самого интересного и забавного, комментарии. В данном проекте мы использовали гем [acts_as_commentable_with_threading](https://github.com/elight/acts_as_commentable_with_threading). Он содержит 2ух уровневую структуру комментариев, поэтому работы нам немного прибавилось. Что бы создать комментарий, нам необходимы 3 значения: пост где будет этот комментарий, пользователь, оставивший комментарий, и непосредственно сам текст комментария. Смотрится все это примерно так:

{% highlight ruby %}
post.build_comment(user_id, body)
{% endhighlight %}

Ну а для "подкомментария" нам так же необходимо знать родительский комментарий, от которого ветка и пойдет, т.е. создание подобного комментария будет выглядеть примерно так:

{% highlight ruby %}
child_comment = post.build_comment(user_id, body)
child_comment.move_to_child_of(comment)
{% endhighlight %}

А теперь давайте создадим от 10 до 21 главных комментариев и до 9ти дочерних для каждого главного, при этом каждый комментарий будет оставлять рандомный пользователь:

{% highlight ruby %}
posts.each do |post|
  rand_user = rnd_user user_count, rnd

  post[:user_id] = rand_user.id
  created_post = rand_user.create_post(post)

  rnd.rand(10..21).times do
    rand_user = rnd_user user_count, rnd
    comment = created_post.build_comment(rand_user.id, 'Comment body')
    comment.save!

    rnd.rand(9).times do
      rand_user = rnd_user user_count, rnd
      child_comment = created_post.build_comment(rand_user.id, 'Comment body')
      child_comment.save!
      child_comment.move_to_child_of(comment)
    end
  end
end
{% endhighlight %}

Хм, рандомное количество комментариев мы сделали, пользователей тоже разных назначили, но вот незадача, у нас body каждого комментария одно и тоже, а именно `'Comment body'`.Что же делать, как быть? Раз уж мы договорились создать подобие "живого" приложения, то и комментарии у нас должны быть разные и тоже живые. Первое, что приходит в голову - опять использовать массив данных, но я слишков ленив, что бы все это набирать, пусть даже копипастить, и тем более придумывать. Второе, что приходит на ум, генерировать рандомную строчку текста. Да идея не плохая, как минимум нам придется писать меньше кода и он по любому будет всегда разный. Но есть одно но: мы пытаемся достигнуть абсолютной правдоподобности, а строки вида `'skjafnskdjn ksajdnf'` нам точно не подойдут как комментарии. Поэтому нам на помощь приходит отличное решение - гем [raingrams](https://github.com/postmodern/raingrams).

Что же такого может этот гем, спросите Вы? На самом деле ничего особенного, Вы просто скармливаете ему текст, а он, в свою очередь, разбивает его на куски и рандомно выдает вам. В чем плюсы? Да они не отличаются от банальной генерации строки, единственное и очевидное отличие - генерируемый текст будет логичен в пределах строки. 

В документации достаточно подробно описанно как гем ставится и настраивается, но я бы хотел уделить внимание 2ум подводным камням, об которые мы споткнулись:

  * Во первых, гем не поддерживает русский язык. Скажем так, он его не видит. Поэтому если для Вас важен русский язык, используйте наш [форк](https://github.com/dointeractive/raingrams), в котором исправлен этот косяк. 

  * Ну а второй момент, в старых версиях существовал метод `train_with_url` в который передавалась ссылка, а он уже все парсил и выдавал конечный результат. К сожалению в свежих версиях этот метод был убран, причем убран очень хитро. Если быть точным, то автор просто вырезал часть определения этого метода, а вторую забыл(а может решил стебануться над простыми парнями как мы, этого я к сожалению не знаю :) ). 

А теперь, используя полученные знания, перепишем наш метод. В качестве текста для `raingrams` мы будем использовать комментарии из пикабу, которые предварительно распарсим:

{% highlight ruby %}
model = QuadgramModel.build do |model|
  doc = Nokogiri::HTML(open('http://pikabu.ru/story/v_den_programmista_pro_logiku_pikabu_685289'))
  doc.search('div.comment_desc').each do |div|
    model.train_with_text(div.inner_text)
    model.refresh
  end
end

# ....

posts.each do |post|
  rand_user = rnd_user user_count, rnd

  post[:user_id] = rand_user.id
  created_post = rand_user.create_post(post)

  rnd.rand(10..21).times do
    rand_user = rnd_user user_count, rnd
    comment = created_post.build_comment(rand_user.id, model.random_sentence)
    comment.save!

    rnd.rand(9).times do
      rand_user = rnd_user user_count, rnd
      child_comment = created_post.build_comment(rand_user.id, model.random_sentence)
      child_comment.save!
      child_comment.move_to_child_of(comment)
    end
  end
end
{% endhighlight %}

Кстати, я уверен, что немного изменив наш скрипт, можно будет создать подобную генератию текстов непосредственно для постов. 

Выглядит здорово, да, может код не самый чистый, в целом скрипт слишком часто обращается к базе, но согласитесь, наш скрипт имитирует реальную активность пользователей. Не идеально конечно же, но все же. Думаю на этом можно было бы закончить, но остался последний момент, который хотелось бы осветить и исправить в нашем скрипте.

Как думаете, где еще нам придется создавать пользователей, которых мы создали в самом начале? Правильно, в тестах, надо же на чем-то тестировать приложение. Так почему бы нам не убить 2ух зайцев и не заменить ручную генерацию пользователей, как это было в начале статьи, на старую добрую фабричную? Так как в нашем проекте мы используем гем  [fabrication](http://www.fabricationgem.org/), то и пример будет с ним. Вы так же можете использовать любую другуюю фабрику.

Для начала определим нашего пользователя. 

{% highlight ruby %}

{% endhighlight %}




{% highlight ruby %}
{% endhighlight %}

